{"createdAt":"2025-12-02T09:58:45.267Z","updatedAt":"2025-12-04T05:16:20.000Z","id":"SJT4XWk57lQ2TPRa","name":"DataHub","active":true,"isArchived":false,"nodes":[{"parameters":{"httpMethod":"POST","path":"85123de5-b769-4366-abcf-5139764d3f77","responseMode":"responseNode","options":{}},"type":"n8n-nodes-base.webhook","typeVersion":2,"position":[-1232,16],"id":"b55d9425-7f3c-45e8-a954-d826dc3b2c35","name":"Webhook","webhookId":"85123de5-b769-4366-abcf-5139764d3f77"},{"parameters":{"mode":"insert","tableName":{"__rl":true,"value":"data_hub_rag","mode":"list","cachedResultName":"data_hub_rag"},"options":{}},"type":"@n8n/n8n-nodes-langchain.vectorStoreSupabase","typeVersion":1.3,"position":[1008,96],"id":"0d1b7e54-5435-4435-832c-b78d1f385bc8","name":"Supabase Vector Store","credentials":{"supabaseApi":{"id":"YNsWvnTcojS2SEfy","name":"Supabase account 3"}}},{"parameters":{"options":{}},"type":"@n8n/n8n-nodes-langchain.documentDefaultDataLoader","typeVersion":1.1,"position":[1168,320],"id":"49e36d31-47c3-4746-9e60-ff360d5af28f","name":"Default Data Loader"},{"parameters":{"options":{}},"type":"@n8n/n8n-nodes-langchain.embeddingsOpenAi","typeVersion":1.2,"position":[1040,320],"id":"8849f914-36ac-42fc-9b09-befa070b5454","name":"Embeddings OpenAI","credentials":{"openAiApi":{"id":"OIynyE7k2YMj33f3","name":"OpenAi account 15"}}},{"parameters":{"audioUrl":"={{ $json.upload_url }}","additionalFields":{}},"type":"n8n-nodes-assemblyai.assemblyAi","typeVersion":1,"position":[112,16],"id":"015f7eb9-f651-42e1-881c-f0360ddaa068","name":"Create a transcription","credentials":{"assemblyAiApi":{"id":"dbWlDBJVIeKaBz7y","name":"AssemblyAI account 2"}}},{"parameters":{"resource":"file","fileInput":"file_0"},"type":"n8n-nodes-assemblyai.assemblyAi","typeVersion":1,"position":[-112,16],"id":"b220afe8-5001-46fd-96cf-310cd041f807","name":"Upload a file","credentials":{"assemblyAiApi":{"id":"dbWlDBJVIeKaBz7y","name":"AssemblyAI account 2"}}},{"parameters":{"options":{}},"type":"@n8n/n8n-nodes-langchain.agent","typeVersion":2.1,"position":[-1072,1168],"id":"be621b73-c6e4-428c-9335-59ce0ee5b516","name":"AI Agent","disabled":true},{"parameters":{},"type":"n8n-nodes-base.merge","typeVersion":3.2,"position":[-1328,-416],"id":"4ffc1ad6-187c-41b5-94df-4749f75573d8","name":"Merge"},{"parameters":{"respondWith":"noData","options":{"responseCode":200}},"type":"n8n-nodes-base.respondToWebhook","typeVersion":1.4,"position":[-560,-176],"id":"1d2e5b6e-e6bb-4f07-b9bc-37e25ee8ab8a","name":"Respond to Webhook"},{"parameters":{"conditions":{"options":{"caseSensitive":true,"leftValue":"","typeValidation":"strict","version":2},"conditions":[{"id":"72d45d02-3c84-4a89-a656-ac2b2b2e53e8","leftValue":"={{ $json.status }}","rightValue":"completed","operator":{"type":"string","operation":"equals","name":"filter.operator.equals"}}],"combinator":"and"},"options":{}},"type":"n8n-nodes-base.if","typeVersion":2.2,"position":[560,-48],"id":"e9a1b546-021b-4c35-b687-45942a17cea1","name":"If"},{"parameters":{"operation":"get","transcriptId":"={{ $json.id }}"},"type":"n8n-nodes-assemblyai.assemblyAi","typeVersion":1,"position":[336,16],"id":"0c33c09f-ea9e-4076-b5ea-620a2ffffe90","name":"Get a transcription","credentials":{"assemblyAiApi":{"id":"dbWlDBJVIeKaBz7y","name":"AssemblyAI account 2"}}},{"parameters":{},"type":"n8n-nodes-base.wait","typeVersion":1.1,"position":[784,112],"id":"b52ec746-f7cc-4ff6-86b1-15134e12b69a","name":"Wait","webhookId":"1e1d7d6c-0934-4ba8-86cd-8492c5f00dae"},{"parameters":{"assignments":{"assignments":[{"id":"3c9272fd-0018-4d20-997a-3e571bc6f281","name":"content","value":"={{ $json.text }}","type":"string"}]},"options":{}},"type":"n8n-nodes-base.set","typeVersion":3.4,"position":[784,-112],"id":"27e207f5-1b69-486d-8a4e-ebc22f8d8319","name":"Edit Fields"},{"parameters":{"options":{}},"type":"n8n-nodes-base.splitInBatches","typeVersion":3,"position":[-784,16],"id":"2f66d4f2-63c5-42c6-9d91-3b63528152b1","name":"Loop Over Items"},{"parameters":{"jsCode":"// Collect only the binary-split items\nconst output = [];\n\nfor (const item of items) {\n  const binary = item.binary || {};\n\n  // For each binary file, emit a new itemâ€”with ONLY binary data\n  for (const [key, data] of Object.entries(binary)) {\n    output.push({\n      json: {},     // required by n8n structure but left empty\n      binary: {\n        [key]: data\n      }\n    });\n  }\n}\n\nreturn output;\n"},"type":"n8n-nodes-base.code","typeVersion":2,"position":[-1008,16],"id":"4a511e68-fe0d-42fb-9291-6fc1c6e66918","name":"BinerySplitter","alwaysOutputData":true,"retryOnFail":true},{"parameters":{"jsCode":"// n8n Code node (JavaScript)\n// Mode: Run Once for All Items\n// Optimized for large files (up to 400 MB)\n\nconst MAX_MAGIC_BYTES = 4096; // Only read first 4KB for file type detection\nconst MAX_BINARY_SIZE_TO_RETURN = 350 * 1024 * 1024; // 350 MB - handle files up to 300 MB with buffer\n\nconst bufferFromBinaryData = (data, maxBytes = null) => {\n  if (!data) return null;\n  \n  let buffer = null;\n  \n  if (typeof data === 'string') {\n    const base64PrefixIndex = data.indexOf('base64,');\n    if (base64PrefixIndex !== -1) {\n      const base64Data = data.slice(base64PrefixIndex + 7);\n      if (maxBytes) {\n        // For large files, only decode what we need\n        const estimatedBytes = (base64Data.length * 3) / 4;\n        if (estimatedBytes > maxBytes) {\n          // Only decode first portion\n          const charsNeeded = Math.ceil((maxBytes * 4) / 3);\n          buffer = Buffer.from(base64Data.slice(0, charsNeeded), 'base64');\n        } else {\n          buffer = Buffer.from(base64Data, 'base64');\n        }\n      } else {\n        buffer = Buffer.from(base64Data, 'base64');\n      }\n    } else {\n      if (maxBytes) {\n        const estimatedBytes = (data.length * 3) / 4;\n        if (estimatedBytes > maxBytes) {\n          const charsNeeded = Math.ceil((maxBytes * 4) / 3);\n          buffer = Buffer.from(data.slice(0, charsNeeded), 'base64');\n        } else {\n          buffer = Buffer.from(data, 'base64');\n        }\n      } else {\n        buffer = Buffer.from(data, 'base64');\n      }\n    }\n  } else if (typeof Buffer !== 'undefined' && Buffer.isBuffer(data)) {\n    buffer = maxBytes ? data.slice(0, maxBytes) : data;\n  } else if (data instanceof Uint8Array) {\n    buffer = Buffer.from(maxBytes ? data.slice(0, maxBytes) : data);\n  } else {\n    try {\n      buffer = Buffer.from(data);\n      if (maxBytes && buffer.length > maxBytes) {\n        buffer = buffer.slice(0, maxBytes);\n      }\n    } catch (err) {\n      return null;\n    }\n  }\n  \n  return buffer;\n};\n\nconst detectByMagic = (buf) => {\n  if (!buf || buf.length < 12) return null;\n  \n  // Check magic bytes (only need first few bytes)\n  if (buf[0] === 0xFF && buf[1] === 0xD8) return { mime: 'image/jpeg', ext: 'jpg' };\n  if (buf[0] === 0x89 && buf[1] === 0x50 && buf[2] === 0x4E && buf[3] === 0x47) return { mime: 'image/png', ext: 'png' };\n  \n  if (buf.length >= 6) {\n    const gifHeader = buf.slice(0, 6).toString('ascii');\n    if (gifHeader === 'GIF87a' || gifHeader === 'GIF89a') return { mime: 'image/gif', ext: 'gif' };\n  }\n  \n  if (buf.length >= 4) {\n    const pdfHeader = buf.slice(0, 4).toString('ascii');\n    if (pdfHeader === '%PDF') return { mime: 'application/pdf', ext: 'pdf' };\n  }\n  \n  if (buf[0] === 0x50 && buf[1] === 0x4B && buf[2] === 0x03 && buf[3] === 0x04) return { mime: 'application/zip', ext: 'zip' };\n  \n  if (buf.length >= 8) {\n    const ftyp = buf.slice(4, 8).toString('ascii');\n    if (ftyp === 'ftyp') return { mime: 'video/mp4', ext: 'mp4' };\n  }\n  \n  if (buf.length >= 12) {\n    const riff = buf.slice(0, 4).toString('ascii');\n    const webp = buf.slice(8, 12).toString('ascii');\n    if (riff === 'RIFF' && webp === 'WEBP') return { mime: 'image/webp', ext: 'webp' };\n  }\n  \n  if (buf[0] === 0x42 && buf[1] === 0x4D) return { mime: 'image/bmp', ext: 'bmp' };\n  \n  if (buf.length >= 3) {\n    const id3 = buf.slice(0, 3).toString('ascii');\n    if (id3 === 'ID3') return { mime: 'audio/mpeg', ext: 'mp3' };\n  }\n  \n  if (buf[0] === 0xFF && (buf[1] & 0xE0) === 0xE0) return { mime: 'audio/mpeg', ext: 'mp3' };\n  if (buf[0] === 0xD0 && buf[1] === 0xCF && buf[2] === 0x11 && buf[3] === 0xE0) return { mime: 'application/vnd.ms-office', ext: 'doc' };\n  \n  return null;\n};\n\nasync function main() {\n  const items = $input.all();\n  const out = [];\n\n  let fileTypeLib = null;\n  try {\n    fileTypeLib = await import('file-type');\n  } catch (err) {\n    fileTypeLib = null;\n  }\n\n  for (const item of items) {\n    try {\n      const json = item.json ? { ...item.json } : {};\n      const binary = item.binary ? { ...item.binary } : {};\n\n      const binaryKeys = Object.keys(binary);\n      if (binaryKeys.length === 0) {\n        json.fileType = null;\n        json.fileExtension = null;\n        out.push({ json, binary });\n        continue;\n      }\n\n      const firstKey = binaryKeys[0];\n      const binObj = binary[firstKey];\n      \n      // Get file size estimate\n      let fileSize = 0;\n      if (binObj.data) {\n        if (typeof binObj.data === 'string') {\n          // Estimate from base64 string\n          fileSize = (binObj.data.length * 3) / 4;\n        } else if (Buffer.isBuffer(binObj.data)) {\n          fileSize = binObj.data.length;\n        } else if (binObj.data instanceof Uint8Array) {\n          fileSize = binObj.data.length;\n        }\n      }\n      \n      // Only read first few KB for file type detection (magic bytes)\n      const buf = bufferFromBinaryData(binObj.data, MAX_MAGIC_BYTES);\n\n      let detected = null;\n      \n      // Try file-type library first (only if buffer is small enough)\n      if (buf && buf.length <= MAX_MAGIC_BYTES && fileTypeLib && fileTypeLib.fileTypeFromBuffer) {\n        try {\n          const res = await fileTypeLib.fileTypeFromBuffer(buf);\n          if (res) detected = { mime: res.mime, ext: res.ext };\n        } catch (err) {\n          // Fall back to magic bytes\n          detected = null;\n        }\n      }\n\n      // Fall back to magic bytes detection\n      if (!detected && buf) {\n        detected = detectByMagic(buf);\n      }\n\n      // Final fallback to metadata\n      if (!detected) {\n        if (binObj.mimeType) {\n          detected = { \n            mime: binObj.mimeType, \n            ext: (binObj.fileName && binObj.fileName.split('.').pop()) || null \n          };\n        } else if (binObj.fileName) {\n          const extGuess = binObj.fileName.includes('.') \n            ? binObj.fileName.split('.').pop().toLowerCase() \n            : null;\n          detected = { mime: null, ext: extGuess };\n        } else {\n          detected = { mime: 'application/octet-stream', ext: null };\n        }\n      }\n\n      const mime = detected.mime ? detected.mime.toLowerCase() : null;\n      const ext = detected.ext ? detected.ext.toLowerCase() : null;\n\n      // Map high-level type\n      let highLevelType = null;\n      const docExts = ['pdf', 'doc', 'docx'];\n\n      if (ext && docExts.includes(ext)) {\n        highLevelType = 'doc';\n      } else if (mime && (mime.startsWith('application/pdf') || mime.includes('msword') || mime.includes('wordprocessingml'))) {\n        highLevelType = 'doc';\n      } else if (mime && mime.startsWith('audio/')) {\n        highLevelType = 'audio';\n      } else if (mime && mime.startsWith('image/')) {\n        highLevelType = 'image';\n      } else if (mime && mime.startsWith('video/')) {\n        highLevelType = 'video';\n      } else if (ext) {\n        highLevelType = ext;\n      } else if (mime) {\n        highLevelType = mime;\n      } else {\n        highLevelType = 'unknown';\n      }\n\n      json.fileType = highLevelType;\n      json.fileExtension = ext;\n      json.fileSize = fileSize; // Add file size info\n      json.fileSizeMB = (fileSize / (1024 * 1024)).toFixed(2); // Size in MB\n\n      // Pass binary data through for files up to 300 MB\n      // Only read first 4KB for detection, but pass full binary data to next nodes\n      const outBinary = { ...binary };\n      \n      if (fileSize > MAX_BINARY_SIZE_TO_RETURN) {\n        // For files larger than 350MB, warn but still try to pass through\n        // The n8n configuration should handle payload size limits\n        outBinary[firstKey] = {\n          ...binObj,\n          _largeFile: true,\n          _fileSize: fileSize,\n          _warning: 'File exceeds 350MB threshold'\n        };\n        json._largeFileWarning = true;\n      } else {\n        // For files up to 350MB, pass through the binary data\n        outBinary[firstKey] = { ...binObj };\n      }\n\n      out.push({ json, binary: outBinary });\n      \n    } catch (error) {\n      // Error handling for individual items\n      console.error('Error processing item:', error.message);\n      out.push({\n        json: {\n          ...(item.json || {}),\n          fileType: 'error',\n          error: error.message,\n          _processingError: true\n        },\n        binary: item.binary || {}\n      });\n    }\n  }\n\n  return out;\n}\n\nreturn await main();\n\n"},"type":"n8n-nodes-base.code","typeVersion":2,"position":[-560,16],"id":"959fe704-2db8-4bd5-8c61-f80a3a472d23","name":"Code"},{"parameters":{"rules":{"values":[{"conditions":{"options":{"caseSensitive":true,"leftValue":"","typeValidation":"strict","version":2},"conditions":[{"leftValue":"={{ $json.fileType }}","rightValue":"audio","operator":{"type":"string","operation":"equals"},"id":"fe63ec2f-4d8e-498d-be21-52b646a66952"}],"combinator":"and"}},{"conditions":{"options":{"caseSensitive":true,"leftValue":"","typeValidation":"strict","version":2},"conditions":[{"id":"1bbf37e3-ebe2-4df7-8e0f-fd2e7237c432","leftValue":"={{ $json.fileType }}","rightValue":"doc","operator":{"type":"string","operation":"equals","name":"filter.operator.equals"}}],"combinator":"and"}}]},"options":{}},"type":"n8n-nodes-base.switch","typeVersion":3.2,"position":[-336,16],"id":"04f818fa-9332-4e3b-9482-90348989d71b","name":"Switch"},{"parameters":{"mode":"insert","tableName":{"__rl":true,"value":"data_hub_rag","mode":"list","cachedResultName":"data_hub_rag"},"options":{}},"type":"@n8n/n8n-nodes-langchain.vectorStoreSupabase","typeVersion":1.3,"position":[128,400],"id":"3f3306f5-be34-48b8-8857-fccb2fd3f6c1","name":"Supabase Vector Store1","credentials":{"supabaseApi":{"id":"YNsWvnTcojS2SEfy","name":"Supabase account 3"}}},{"parameters":{"dataType":"binary","options":{}},"type":"@n8n/n8n-nodes-langchain.documentDefaultDataLoader","typeVersion":1.1,"position":[288,624],"id":"66b616f0-0337-46aa-a65e-4cc0579cd6d4","name":"Default Data Loader1"},{"parameters":{"options":{}},"type":"@n8n/n8n-nodes-langchain.embeddingsOpenAi","typeVersion":1.2,"position":[160,624],"id":"e7f08d93-f886-4722-99a9-26b491d221cf","name":"Embeddings OpenAI1","credentials":{"openAiApi":{"id":"OIynyE7k2YMj33f3","name":"OpenAi account 15"}}}],"connections":{"Webhook":{"main":[[{"node":"BinerySplitter","type":"main","index":0}]]},"Default Data Loader":{"ai_document":[[{"node":"Supabase Vector Store","type":"ai_document","index":0}]]},"Embeddings OpenAI":{"ai_embedding":[[{"node":"Supabase Vector Store","type":"ai_embedding","index":0}]]},"Create a transcription":{"main":[[{"node":"Get a transcription","type":"main","index":0}]]},"Upload a file":{"main":[[{"node":"Create a transcription","type":"main","index":0}]]},"AI Agent":{"main":[[]]},"Supabase Vector Store":{"main":[[{"node":"Loop Over Items","type":"main","index":0}]]},"Merge":{"main":[[]]},"Get a transcription":{"main":[[{"node":"If","type":"main","index":0}]]},"If":{"main":[[{"node":"Edit Fields","type":"main","index":0}],[{"node":"Wait","type":"main","index":0}]]},"Wait":{"main":[[{"node":"Get a transcription","type":"main","index":0}]]},"Edit Fields":{"main":[[{"node":"Supabase Vector Store","type":"main","index":0}]]},"Loop Over Items":{"main":[[{"node":"Respond to Webhook","type":"main","index":0}],[{"node":"Code","type":"main","index":0}]]},"BinerySplitter":{"main":[[{"node":"Loop Over Items","type":"main","index":0}]]},"Code":{"main":[[{"node":"Switch","type":"main","index":0}]]},"Respond to Webhook":{"main":[[]]},"Switch":{"main":[[{"node":"Upload a file","type":"main","index":0}],[{"node":"Supabase Vector Store1","type":"main","index":0}]]},"Default Data Loader1":{"ai_document":[[{"node":"Supabase Vector Store1","type":"ai_document","index":0}]]},"Embeddings OpenAI1":{"ai_embedding":[[{"node":"Supabase Vector Store1","type":"ai_embedding","index":0}]]},"Supabase Vector Store1":{"main":[[{"node":"Switch","type":"main","index":0}]]}},"settings":{"executionOrder":"v1"},"staticData":null,"meta":{"templateCredsSetupCompleted":true},"pinData":{"Webhook":[{"json":{"headers":{"host":"n8n.thelinkai.com","user-agent":"Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/142.0.0.0 Safari/537.36","content-length":"72586","accept":"*/*","accept-encoding":"gzip, deflate, br, zstd","accept-language":"en-US,en;q=0.9","authorization":"Basic aGFyZGlrQHRoZWxpbmthaS5jb206QWRtaW5AMTIzNA==","content-type":"multipart/form-data; boundary=----WebKitFormBoundary5PYlcBw77zvGoSfd","origin":"http://192.168.1.168:5173","priority":"u=1, i","referer":"http://192.168.1.168:5173/","sec-ch-ua":"\"Chromium\";v=\"142\", \"Google Chrome\";v=\"142\", \"Not_A Brand\";v=\"99\"","sec-ch-ua-mobile":"?0","sec-ch-ua-platform":"\"Windows\"","sec-fetch-dest":"empty","sec-fetch-mode":"cors","sec-fetch-site":"cross-site","x-forwarded-for":"103.39.128.33","x-forwarded-host":"n8n.thelinkai.com","x-forwarded-port":"443","x-forwarded-proto":"https","x-forwarded-server":"cff298b6fc90","x-real-ip":"103.39.128.33"},"params":{},"query":{},"body":{"projectName":"SES BUSINESS & DEVELOPMENT AI AUTOMATION-PHASE 1","title":"dfsda","description":"ASsdfdsf","date":"2025-12-18","duration":"6","meetingType":"client-meeting","timestamp":"2025-12-03T09:52:21.313Z","submittedAt":"2025-12-03T09:52:21.313Z","userEmail":"vignesh@thelinkai.com","userId":"c776b808-697f-4554-b186-fadf6fe2a451","fileCount":"1","fileName_0":"Pounkumar E  .pdf","fileSize_0":"70817","fileType_0":"application/pdf"},"webhookUrl":"https://n8n.thelinkai.com/webhook/85123de5-b769-4366-abcf-5139764d3f77","executionMode":"production"}}]},"versionId":"2a58d0d1-b268-46f8-9fb0-12d929733ac1","triggerCount":1,"tags":[]}